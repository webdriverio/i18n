---
id: configuration
title: कॉन्फिगरेशन
---

यह पेज WebdriverIO MCP सर्वर के लिए सभी कॉन्फिगरेशन विकल्पों का दस्तावेजीकरण करता है।

## MCP सर्वर कॉन्फिगरेशन

MCP सर्वर को Claude Desktop या Claude Code कॉन्फिगरेशन फ़ाइलों के माध्यम से कॉन्फ़िगर किया जाता है।

### बेसिक कॉन्फिगरेशन

#### macOS

`~/Library/Application Support/Claude/claude_desktop_config.json` को संपादित करें:

```json
{
    "mcpServers": {
        "wdio-mcp": {
            "command": "npx",
            "args": ["-y", "@wdio/mcp"]
        }
    }
}
```

#### Windows

`%APPDATA%\Claude\claude_desktop_config.json` को संपादित करें:

```json
{
    "mcpServers": {
        "wdio-mcp": {
            "command": "npx",
            "args": ["-y", "@wdio/mcp"]
        }
    }
}
```

#### Claude Code

अपने प्रोजेक्ट की `.claude/settings.json` को संपादित करें:

```json
{
    "mcpServers": {
        "wdio-mcp": {
            "command": "npx",
            "args": ["-y", "@wdio/mcp"]
        }
    }
}
```

---

## एनवायरनमेंट वेरिएबल्स

Appium सर्वर कनेक्शन और अन्य सेटिंग्स को एनवायरनमेंट वेरिएबल्स के माध्यम से कॉन्फ़िगर करें।

### Appium कनेक्शन

| वेरिएबल | टाइप | डिफ़ॉल्ट | विवरण |
|----------|------|---------|-------------|
| `APPIUM_URL` | string | `127.0.0.1` | Appium सर्वर होस्टनेम |
| `APPIUM_URL_PORT` | number | `4723` | Appium सर्वर पोर्ट |
| `APPIUM_PATH` | string | `/` | Appium सर्वर पाथ |

### एनवायरनमेंट वेरिएबल्स के साथ उदाहरण

```json
{
    "mcpServers": {
        "wdio-mcp": {
            "command": "npx",
            "args": ["-y", "@wdio/mcp"],
            "env": {
                "APPIUM_URL": "192.168.1.100",
                "APPIUM_URL_PORT": "4724",
                "APPIUM_PATH": "/wd/hub"
            }
        }
    }
}
```

---

## ब्राउज़र सेशन विकल्प

`start_browser` टूल के माध्यम से ब्राउज़र सेशन शुरू करते समय उपलब्ध विकल्प।

### `headless`

-   **टाइप:** `boolean`
-   **अनिवार्य:** नहीं
-   **डिफ़ॉल्ट:** `false`

Chrome को हेडलेस मोड में चलाएं (कोई दृश्यमान ब्राउज़र विंडो नहीं)। CI/CD एनवायरनमेंट के लिए उपयोगी या जब आपको ब्राउज़र देखने की आवश्यकता नहीं होती।

### `windowWidth`

-   **टाइप:** `number`
-   **अनिवार्य:** नहीं
-   **डिफ़ॉल्ट:** `1920`
-   **रेंज:** `400` - `3840`

पिक्सेल में प्रारंभिक ब्राउज़र विंडो चौड़ाई।

### `windowHeight`

-   **टाइप:** `number`
-   **अनिवार्य:** नहीं
-   **डिफ़ॉल्ट:** `1080`
-   **रेंज:** `400` - `2160`

पिक्सेल में प्रारंभिक ब्राउज़र विंडो ऊंचाई।

### `navigationUrl`

-   **टाइप:** `string`
-   **अनिवार्य:** नहीं

ब्राउज़र शुरू करने के तुरंत बाद नेविगेट करने के लिए URL। यह `start_browser` के बाद अलग से `navigate` कॉल करने की तुलना में अधिक कुशल है।

**उदाहरण:** ब्राउज़र शुरू करें और एक ही कॉल में नेविगेट करें:
```
Start Chrome and navigate to https://webdriver.io
```

---

## मोबाइल सेशन विकल्प

`start_app_session` टूल के माध्यम से मोबाइल ऐप सेशन शुरू करते समय उपलब्ध विकल्प।

### प्लेटफॉर्म विकल्प

#### `platform`

-   **टाइप:** `string`
-   **अनिवार्य:** हां
-   **वैल्यूज़:** `iOS` | `Android`

ऑटोमेट करने के लिए मोबाइल प्लेटफॉर्म।

#### `platformVersion`

-   **टाइप:** `string`
-   **अनिवार्य:** नहीं

डिवाइस/सिम्युलेटर/एमुलेटर का OS वर्शन (उदाहरण के लिए, iOS के लिए `17.0`, Android के लिए `14`)।

#### `automationName`

-   **टाइप:** `string`
-   **अनिवार्य:** नहीं
-   **वैल्यूज़:** `XCUITest` (iOS), `UiAutomator2` | `Espresso` (Android)

उपयोग करने के लिए ऑटोमेशन ड्राइवर। iOS के लिए डिफ़ॉल्ट `XCUITest` और Android के लिए `UiAutomator2` है।

### डिवाइस विकल्प

#### `deviceName`

-   **टाइप:** `string`
-   **अनिवार्य:** हां

उपयोग करने के लिए डिवाइस, सिम्युलेटर, या एमुलेटर का नाम।

**उदाहरण:**
-   iOS सिम्युलेटर: `iPhone 15 Pro`, `iPad Air (5th generation)`
-   Android एमुलेटर: `Pixel 7`, `Nexus 5X`
-   वास्तविक डिवाइस: आपके सिस्टम में दिखाए गए अनुसार डिवाइस नाम

#### `udid`

-   **टाइप:** `string`
-   **अनिवार्य:** नहीं (वास्तविक iOS डिवाइस के लिए आवश्यक)

यूनिक डिवाइस आइडेंटिफायर। वास्तविक iOS डिवाइस (40-वर्णों का आइडेंटिफायर) के लिए आवश्यक और Android वास्तविक डिवाइस के लिए अनुशंसित।

**UDID खोजना:**
-   **iOS:** डिवाइस कनेक्ट करें, Finder/iTunes खोलें, डिवाइस पर क्लिक करें → सीरियल नंबर (UDID प्रकट करने के लिए क्लिक करें)
-   **Android:** टर्मिनल में `adb devices` चलाएं

### ऐप विकल्प

#### `appPath`

-   **टाइप:** `string`
-   **अनिवार्य:** नहीं*

इंस्टॉल और लॉन्च करने के लिए एप्लिकेशन फ़ाइल का पाथ।

**समर्थित फॉर्मेट:**
-   iOS सिम्युलेटर: `.app` डायरेक्टरी
-   iOS वास्तविक डिवाइस: `.ipa` फ़ाइल
-   Android: `.apk` फ़ाइल

*या तो `appPath` प्रदान किया जाना चाहिए, या पहले से चल रहे ऐप से कनेक्ट करने के लिए `noReset: true` होना चाहिए।

#### `appWaitActivity`

-   **टाइप:** `string`
-   **अनिवार्य:** नहीं (केवल Android)

ऐप लॉन्च होने पर प्रतीक्षा करने के लिए एक्टिविटी। यदि निर्दिष्ट नहीं है, तो ऐप की मुख्य/लॉन्चर एक्टिविटी का उपयोग किया जाता है।

**उदाहरण:** `com.example.app.MainActivity`

### सेशन स्टेट विकल्प

#### `noReset`

-   **टाइप:** `boolean`
-   **अनिवार्य:** नहीं
-   **डिफ़ॉल्ट:** `false`

सेशन के बीच ऐप स्टेट को संरक्षित करें। जब `true` होता है:
-   ऐप डेटा संरक्षित रहता है (लॉगिन स्टेट, प्रेफरेंस, आदि)
-   सेशन बंद होने के बजाय **डिटैच** होगा (ऐप चलता रहता है)
-   कई सेशन में यूजर जर्नी का परीक्षण करने के लिए उपयोगी
-   पहले से चलने वाले ऐप से कनेक्ट करने के लिए `appPath` के बिना भी उपयोग किया जा सकता है

#### `fullReset`

-   **टाइप:** `boolean`
-   **अनिवार्य:** नहीं
-   **डिफ़ॉल्ट:** `true`

सेशन से पहले ऐप को पूरी तरह से रीसेट करें। जब `true` होता है:
-   iOS: ऐप को अनइंस्टॉल और फिर से इंस्टॉल करता है
-   Android: ऐप डेटा और कैश को साफ़ करता है
-   क्लीन स्टेट से शुरू करने के लिए उपयोगी

ऐप स्टेट को पूरी तरह से संरक्षित करने के लिए `fullReset: false` को `noReset: true` के साथ सेट करें।

### सेशन टाइमआउट

#### `newCommandTimeout`

-   **टाइप:** `number`
-   **अनिवार्य:** नहीं
-   **डिफ़ॉल्ट:** `60`

Appium कितने समय (सेकंड में) तक नए कमांड के लिए प्रतीक्षा करेगा इससे पहले कि वह मान ले कि क्लाइंट छोड़ चुका है और सेशन समाप्त कर दे। लंबे डीबगिंग सेशन के लिए इस वैल्यू को बढ़ाएं।

**उदाहरण:**
-   `60` - डिफ़ॉल्ट, अधिकांश ऑटोमेशन के लिए उपयुक्त
-   `300` - 5 मिनट, डीबगिंग या धीमे ऑपरेशन के लिए
-   `600` - 10 मिनट, बहुत लंबे समय तक चलने वाले टेस्ट के लिए

### ऑटोमैटिक हैंडलिंग विकल्प

#### `autoGrantPermissions`

-   **टाइप:** `boolean`
-   **अनिवार्य:** नहीं
-   **डिफ़ॉल्ट:** `true`

इंस्टॉल/लॉन्च पर ऐप अनुमतियों को स्वचालित रूप से प्रदान करें। जब `true` होता है:
-   कैमरा, माइक्रोफोन, लोकेशन, आदि अनुमतियां स्वचालित रूप से दी जाती हैं
-   मैनुअल अनुमति डायलॉग हैंडलिंग की आवश्यकता नहीं होती
-   अनुमति पॉपअप से बचकर ऑटोमेशन को सुव्यवस्थित करता है

:::note केवल Android
यह विकल्प मुख्य रूप से Android को प्रभावित करता है। iOS अनुमतियों को सिस्टम प्रतिबंधों के कारण अलग तरह से संभाला जाना चाहिए।
:::

#### `autoAcceptAlerts`

-   **टाइप:** `boolean`
-   **अनिवार्य:** नहीं
-   **डिफ़ॉल्ट:** `true`

ऑटोमेशन के दौरान दिखाई देने वाले सिस्टम अलर्ट (डायलॉग) को स्वचालित रूप से स्वीकार करें।

**स्वचालित रूप से स्वीकृत अलर्ट के उदाहरण:**
-   "नोटिफिकेशन की अनुमति दें?"
-   "ऐप आपके लोकेशन तक पहुंचना चाहेगा"
-   "ऐप को फोटो एक्सेस करने की अनुमति दें?"

#### `autoDismissAlerts`

-   **टाइप:** `boolean`
-   **अनिवार्य:** नहीं
-   **डिफ़ॉल्ट:** `false`

स्वीकार करने के बजाय सिस्टम अलर्ट को खारिज (रद्द) करें। जब `true` पर सेट किया जाता है, तो `autoAcceptAlerts` से प्राथमिकता लेता है।

### Appium सर्वर ओवरराइड

आप प्रति-सेशन के आधार पर Appium सर्वर कनेक्शन को ओवरराइड कर सकते हैं:

#### `appiumHost`

-   **टाइप:** `string`
-   **अनिवार्य:** नहीं

Appium सर्वर होस्टनेम। `APPIUM_URL` एनवायरनमेंट वेरिएबल को ओवरराइड करता है।

#### `appiumPort`

-   **टाइप:** `number`
-   **अनिवार्य:** नहीं

Appium सर्वर पोर्ट। `APPIUM_URL_PORT` एनवायरनमेंट वेरिएबल को ओवरराइड करता है।

#### `appiumPath`

-   **टाइप:** `string`
-   **अनिवार्य:** नहीं

Appium सर्वर पाथ। `APPIUM_PATH` एनवायरनमेंट वेरिएबल को ओवरराइड करता है।

---

## एलिमेंट डिटेक्शन विकल्प

`get_visible_elements` टूल के लिए विकल्प।

### `elementType`

-   **टाइप:** `string`
-   **अनिवार्य:** नहीं
-   **डिफ़ॉल्ट:** `interactable`
-   **वैल्यूज़:** `interactable` | `visual` | `all`

रिटर्न करने के लिए एलिमेंट के प्रकार:
-   `interactable`: बटन, लिंक, इनपुट और अन्य क्लिक करने योग्य एलिमेंट
-   `visual`: इमेज, SVG और विजुअल एलिमेंट
-   `all`: इंटरैक्टेबल और विजुअल दोनों एलिमेंट

### `inViewportOnly`

-   **टाइप:** `boolean`
-   **अनिवार्य:** नहीं
-   **डिफ़ॉल्ट:** `true`

केवल वे एलिमेंट रिटर्न करें जो वर्तमान व्यूपोर्ट में दिखाई देते हैं। जब `false` होता है, तो व्यू हायरार्की में सभी एलिमेंट रिटर्न करता है (ऑफ-स्क्रीन एलिमेंट्स को खोजने के लिए उपयोगी)।

### `includeContainers`

-   **टाइप:** `boolean`
-   **अनिवार्य:** नहीं
-   **डिफ़ॉल्ट:** `false`

परिणामों में कंटेनर/लेआउट एलिमेंट शामिल करें। जब `true` होता है:

**Android कंटेनर शामिल:**
-   `ViewGroup`, `FrameLayout`, `LinearLayout`
-   `RelativeLayout`, `ConstraintLayout`
-   `ScrollView`, `RecyclerView`

**iOS कंटेनर शामिल:**
-   `View`, `StackView`, `CollectionView`
-   `ScrollView`, `TableView`

लेआउट समस्याओं का डीबग करने या व्यू हायरार्की को समझने के लिए उपयोगी।

### `includeBounds`

-   **टाइप:** `boolean`
-   **अनिवार्य:** नहीं
-   **डिफ़ॉल्ट:** `false`

रिस्पॉन्स में एलिमेंट के बाउंड्स/कोऑर्डिनेट्स (x, y, width, height) शामिल करें। इसके लिए `true` सेट करें:
-   कोऑर्डिनेट-आधारित इंटरैक्शन
-   लेआउट डीबगिंग
-   विजुअल एलिमेंट पोजिशनिंग

### पेजिनेशन विकल्प

बहुत सारे एलिमेंट्स वाले बड़े पेजों के लिए, टोकन उपयोग को कम करने के लिए पेजिनेशन का उपयोग करें:

#### `limit`

-   **टाइप:** `number`
-   **अनिवार्य:** नहीं
-   **डिफ़ॉल्ट:** `0` (असीमित)

रिटर्न करने के लिए एलिमेंट की अधिकतम संख्या।

#### `offset`

-   **टाइप:** `number`
-   **अनिवार्य:** नहीं
-   **डिफ़ॉल्ट:** `0`

परिणाम देने से पहले छोड़ने के लिए एलिमेंट की संख्या।

**उदाहरण:** एलिमेंट 21-40 प्राप्त करें:
```
Get visible elements with limit 20 and offset 20
```

---

## एक्सेसिबिलिटी ट्री विकल्प

`get_accessibility` टूल के लिए विकल्प (केवल ब्राउज़र)।

### `limit`

-   **टाइप:** `number`
-   **अनिवार्य:** नहीं
-   **डिफ़ॉल्ट:** `100`

रिटर्न करने के लिए नोड्स की अधिकतम संख्या। असीमित के लिए `0` का उपयोग करें (बड़े पेजों के लिए अनुशंसित नहीं)।

### `offset`

-   **टाइप:** `number`
-   **अनिवार्य:** नहीं
-   **डिफ़ॉल्ट:** `0`

पेजिनेशन के लिए स्किप करने के लिए नोड्स की संख्या।

### `roles`

-   **टाइप:** `string[]`
-   **अनिवार्य:** नहीं
-   **डिफ़ॉल्ट:** सभी रोल्स

विशिष्ट एक्सेसिबिलिटी रोल्स के लिए फिल्टर।

**कॉमन रोल्स:** `button`, `link`, `textbox`, `checkbox`, `radio`, `heading`, `img`, `listitem`

**उदाहरण:** केवल बटन और लिंक प्राप्त करें:
```
Get accessibility tree filtered to button and link roles
```

### `namedOnly`

-   **टाइप:** `boolean`
-   **अनिवार्य:** नहीं
-   **डिफ़ॉल्ट:** `true`

केवल वे नोड्स वापस करें जिनके पास नाम/लेबल है। अनोनिमस कंटेनर्स को फ़िल्टर आउट करता है और परिणामों में नॉइज कम करता है।

---

## स्क्रीनशॉट विकल्प

`take_screenshot` टूल के लिए विकल्प।

### `outputPath`

-   **टाइप:** `string`
-   **अनिवार्य:** नहीं

स्क्रीनशॉट फ़ाइल को सहेजने का पाथ। यदि प्रदान नहीं किया गया है, तो बेस64-एन्कोडेड इमेज डेटा रिटर्न करता है।

### ऑटोमैटिक ऑप्टिमाइजेशन

LLM खपत के लिए अनुकूलित करने के लिए स्क्रीनशॉट स्वचालित रूप से प्रोसेस किए जाते हैं:

| ऑप्टिमाइजेशन | वैल्यू | विवरण |
|--------------|-------|-------------|
| मैक्स डायमेंशन | 2000px | 2000px से बड़ी इमेज स्केल डाउन की जाती हैं |
| मैक्स फाइल साइज़ | 1MB | 1MB से कम रखने के लिए इमेज कंप्रेस की जाती हैं |
| फॉर्मेट | PNG/JPEG | अधिकतम कंप्रेशन के साथ PNG; आवश्यकतानुसार साइज़ के लिए JPEG |

यह ऑप्टिमाइजेशन सुनिश्चित करता है कि स्क्रीनशॉट को टोकन सीमा से अधिक हुए बिना कुशलतापूर्वक प्रोसेस किया जा सके।

---

## सेशन व्यवहार

### सेशन प्रकार

MCP सर्वर उचित टूल और व्यवहार प्रदान करने के लिए सेशन प्रकार को ट्रैक करता है:

| टाइप | विवरण | ऑटो-डिटैच |
|------|-------------|------------|
| `browser` | Chrome ब्राउज़र सेशन | नहीं |
| `ios` | iOS ऐप सेशन | हां (यदि `noReset: true` या कोई `appPath` नहीं) |
| `android` | Android ऐप सेशन | हां (यदि `noReset: true` या कोई `appPath` नहीं) |

### सिंगल-सेशन मॉडल

MCP सर्वर **सिंगल-सेशन मॉडल** के साथ काम करता है:

-   एक समय में केवल एक ब्राउज़र या ऐप सेशन सक्रिय हो सकता है
-   नया सेशन शुरू करने से वर्तमान सेशन बंद/डिटैच हो जाएगा
-   सेशन स्टेट टूल कॉल में ग्लोबली बनाए रखा जाता है

### डिटैच बनाम क्लोज़

| एक्शन | `detach: false` (क्लोज़) | `detach: true` (डिटैच) |
|--------|-------------------------|-------------------------|
| ब्राउज़र | पूरी तरह से Chrome बंद करता है | Chrome चलता रहता है, WebDriver डिस्कनेक्ट हो जाता है |
| मोबाइल ऐप | ऐप को टर्मिनेट करता है | ऐप को वर्तमान स्थिति में चालू रखता है |
| यूज़ केस | अगले सेशन के लिए क्लीन स्लेट | स्टेट संरक्षित करें, मैनुअल इंस्पेक्शन |

---

## परफॉर्मेंस कन्सिडरेशंस

MCP सर्वर Claude को डेटा भेजते समय टोकन उपयोग को कम करने के लिए **TOON (टोकन-ओरिएंटेड ऑब्जेक्ट नोटेशन)** फॉर्मेट का उपयोग करके कुशल LLM संचार के लिए अनुकूलित है।

### ब्राउज़र ऑटोमेशन

-   **हेडलेस मोड** तेज़ है लेकिन विज़ुअल एलिमेंट्स रेंडर नहीं करता
-   **छोटे विंडो साइज़** स्क्रीनशॉट कैप्चर समय कम करते हैं
-   **एलिमेंट डिटेक्शन** एकल स्क्रिप्ट एक्जीक्यूशन के साथ अनुकूलित है
-   **स्क्रीनशॉट ऑप्टिमाइजेशन** इमेज को कुशल प्रोसेसिंग के लिए 1MB से कम रखता है
-   **`inViewportOnly: true`** (डिफ़ॉल्ट) केवल दृश्यमान एलिमेंट्स के लिए फिल्टर करता है

### मोबाइल ऑटोमेशन

-   **XML पेज सोर्स पार्सिंग** केवल 2 HTTP कॉल का उपयोग करता है (पारंपरिक एलिमेंट क्वेरीज़ के लिए 600+ के विपरीत)
-   **एक्सेसिबिलिटी ID सेलेक्टर्स** सबसे तेज़ और सबसे विश्वसनीय हैं
-   **XPath सेलेक्टर्स** सबसे धीमे हैं - केवल अंतिम विकल्प के रूप में उपयोग करें
-   **`inViewportOnly: true`** (डिफ़ॉल्ट) एलिमेंट काउंट को काफी कम करता है
-   **पेजिनेशन** (`limit` और `offset`) कई एलिमेंट्स वाले स्क्रीन के लिए टोकन उपयोग कम करता है
-   **`includeBounds: false`** (डिफ़ॉल्ट) जब तक आवश्यक न हो कोऑर्डिनेट डेटा को छोड़ देता है

### टोकन यूसेज टिप्स

| सेटिंग | प्रभाव |
|---------|--------|
| `inViewportOnly: true` | ऑफ-स्क्रीन एलिमेंट्स को फिल्टर करता है, रिस्पॉन्स साइज़ कम करता है |
| `includeContainers: false` | लेआउट एलिमेंट्स को बाहर रखता है (ViewGroup, आदि) |
| `includeBounds: false` | x/y/width/height डेटा को छोड़ देता है |
| `limit` पेजिनेशन के साथ | एक साथ सभी के बजाय बैचों में एलिमेंट्स को प्रोसेस करें |
| `namedOnly: true` (एक्सेसिबिलिटी) | अनोनिमस नोड्स को फिल्टर करता है |

---

## Appium सर्वर सेटअप

मोबाइल ऑटोमेशन का उपयोग करने से पहले, सुनिश्चित करें कि Appium सही ढंग से कॉन्फ़िगर है।

### बेसिक सेटअप

```sh
# Appium को ग्लोबली इंस्टॉल करें
npm install -g appium

# ड्राइवर इंस्टॉल करें
appium driver install xcuitest    # iOS
appium driver install uiautomator2  # Android

# सर्वर शुरू करें
appium
```

### कस्टम सर्वर कॉन्फिगरेशन

```sh
# कस्टम होस्ट और पोर्ट के साथ शुरू करें
appium --address 0.0.0.0 --port 4724

# लॉगिंग के साथ शुरू करें
appium --log-level debug

# विशिष्ट बेस पाथ के साथ शुरू करें
appium --base-path /wd/hub
```

### इंस्टॉलेशन वेरिफाई करें

```sh
# इंस्टॉल किए गए ड्राइवर्स चेक करें
appium driver list --installed

# Appium वर्जन चेक करें
appium --version

# कनेक्शन टेस्ट करें
curl http://localhost:4723/status
```

---

## ट्रबलशूटिंग कॉन्फिगरेशन

### MCP सर्वर शुरू नहीं होता

1. वेरिफाई करें कि npm/npx इंस्टॉल है: `npm --version`
2. मैन्युअली चलाने का प्रयास करें: `npx @wdio/mcp`
3. त्रुटियों के लिए Claude Desktop लॉग जांचें

### Appium कनेक्शन समस्याएं

1. वेरिफाई करें कि Appium चल रहा है: `curl http://localhost:4723/status`
2. जांचें कि एनवायरनमेंट वेरिएबल्स Appium सर्वर सेटिंग्स से मेल खाते हैं
3. सुनिश्चित करें कि फायरवॉल Appium पोर्ट पर कनेक्शन की अनुमति देता है

### सेशन शुरू नहीं होता

1. **ब्राउज़र:** सुनिश्चित करें कि Chrome इंस्टॉल है
2. **iOS:** वेरिफाई करें कि Xcode और सिम्युलेटर उपलब्ध हैं
3. **Android:** जांचें `ANDROID_HOME` और एमुलेटर चल रहा है
4. विस्तृत त्रुटि संदेशों के लिए Appium सर्वर लॉग देखें

### सेशन टाइमआउट

यदि डीबगिंग के दौरान सेशन टाइमआउट हो रहे हैं:
1. सेशन शुरू करते समय `newCommandTimeout` बढ़ाएं
2. सेशन के बीच स्टेट को संरक्षित करने के लिए `noReset: true` का उपयोग करें
3. ऐप को चलता रखने के लिए बंद करते समय `detach: true` का उपयोग करें