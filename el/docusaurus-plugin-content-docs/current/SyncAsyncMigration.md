---
id: async-migration
title: Από Sync σε Async
---

Λόγω αλλαγών στο V8, η ομάδα του WebdriverIO [ανακοίνωσε](https://webdriver.io/blog/2021/07/28/sync-api-deprecation) την κατάργηση της σύγχρονης εκτέλεσης εντολών μέχρι τον Απρίλιο του 2023. Η ομάδα έχει εργαστεί σκληρά για να κάνει τη μετάβαση όσο το δυνατόν πιο εύκολη. Σε αυτόν τον οδηγό εξηγούμε πώς μπορείτε σταδιακά να μεταφέρετε τη σουίτα δοκιμών σας από sync σε async. Ως παράδειγμα έργου χρησιμοποιούμε το [Cucumber Boilerplate](https://github.com/webdriverio/cucumber-boilerplate), αλλά η προσέγγιση είναι ίδια και με όλα τα άλλα έργα.

## Promises στην JavaScript

Ο λόγος για τον οποίο η σύγχρονη εκτέλεση ήταν δημοφιλής στο WebdriverIO είναι επειδή αφαιρεί την πολυπλοκότητα διαχείρισης των promises. Ιδιαίτερα αν προέρχεστε από άλλες γλώσσες όπου αυτή η έννοια δεν υπάρχει με αυτόν τον τρόπο, μπορεί να είναι συγχυστικό στην αρχή. Ωστόσο, οι Promises είναι ένα πολύ ισχυρό εργαλείο για τη διαχείριση ασύγχρονου κώδικα και η σημερινή JavaScript το κάνει στην πραγματικότητα εύκολο στη διαχείριση. Εάν δεν έχετε εργαστεί ποτέ με Promises, σας συνιστούμε να ελέγξετε τον [οδηγό αναφοράς MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) καθώς θα ήταν εκτός πλαισίου να το εξηγήσουμε εδώ.

## Μετάβαση σε Async

Ο testrunner του WebdriverIO μπορεί να χειριστεί ασύγχρονη και σύγχρονη εκτέλεση μέσα στην ίδια σουίτα δοκιμών. Αυτό σημαίνει ότι μπορείτε σταδιακά να μεταφέρετε τις δοκιμές και τα PageObjects σας βήμα προς βήμα με τον δικό σας ρυθμό. Για παράδειγμα, το Cucumber Boilerplate έχει ορίσει [ένα μεγάλο σύνολο ορισμών βημάτων](https://github.com/webdriverio/cucumber-boilerplate/tree/main/src/support/action) για να αντιγράψετε στο έργο σας. Μπορούμε να προχωρήσουμε και να μεταφέρουμε έναν ορισμό βήματος ή ένα αρχείο κάθε φορά.

:::tip

Το WebdriverIO προσφέρει ένα [codemod](https://github.com/webdriverio/codemod) που επιτρέπει τη μετατροπή του συγχρονισμένου κώδικά σας σε ασύγχρονο κώδικα σχεδόν πλήρως αυτόματα. Εκτελέστε πρώτα το codemod όπως περιγράφεται στα έγγραφα και χρησιμοποιήστε αυτόν τον οδηγό για χειροκίνητη μετάβαση εάν χρειάζεται.

:::

Σε πολλές περιπτώσεις, το μόνο που χρειάζεται να κάνετε είναι να κάνετε τη συνάρτηση στην οποία καλείτε εντολές του WebdriverIO `async` και να προσθέσετε ένα `await` μπροστά από κάθε εντολή. Κοιτάζοντας το πρώτο αρχείο `clearInputField.ts` για να μετατραπεί στο boilerplate project, μετατρέπουμε από:

```ts
export default (selector: Selector) => {
    $(selector).clearValue();
};
```

σε:

```ts
export default async (selector: Selector) => {
    await $(selector).clearValue();
};
```

Αυτό είναι όλο. Μπορείτε να δείτε την πλήρη δέσμευση με όλα τα παραδείγματα επανεγγραφής εδώ:

#### Commits:

- _transform all step definitions_ [[af6625f]](https://github.com/webdriverio/cucumber-boilerplate/pull/481/commits/af6625fcd01dc087479e84562f237ecf38b3537d)

:::info
Αυτή η μετάβαση είναι ανεξάρτητη από το αν χρησιμοποιείτε TypeScript ή όχι. Εάν χρησιμοποιείτε TypeScript, απλώς βεβαιωθείτε ότι τελικά αλλάζετε την ιδιότητα `types` στο `tsconfig.json` σας από `webdriverio/sync` σε `@wdio/globals/types`. Επίσης, βεβαιωθείτε ότι ο στόχος μεταγλώττισής σας έχει οριστεί τουλάχιστον σε `ES2018`.
:::

## Ειδικές Περιπτώσεις

Υπάρχουν φυσικά πάντα ειδικές περιπτώσεις όπου πρέπει να δώσετε λίγο περισσότερη προσοχή.

### ForEach Loops

Εάν έχετε έναν βρόχο `forEach`, π.χ. για επανάληψη στοιχείων, πρέπει να βεβαιωθείτε ότι η επανάκληση επαναλήπτη χειρίζεται σωστά με ασύγχρονο τρόπο, π.χ.:

```js
const elems = $$('div')
elems.forEach((elem) => {
    elem.click()
})
```

Η συνάρτηση που περνάμε στο `forEach` είναι μια συνάρτηση επαναλήπτη. Σε ένα σύγχρονο κόσμο θα έκανε κλικ σε όλα τα στοιχεία πριν προχωρήσει. Εάν μετατρέψουμε αυτό σε ασύγχρονο κώδικα, πρέπει να διασφαλίσουμε ότι περιμένουμε κάθε συνάρτηση επαναλήπτη να ολοκληρώσει την εκτέλεση. Προσθέτοντας `async`/`await` αυτές οι συναρτήσεις επαναλήπτη θα επιστρέψουν μια υπόσχεση που πρέπει να επιλύσουμε. Τώρα, το `forEach` δεν είναι πλέον ιδανικό για την επανάληψη των στοιχείων επειδή δεν επιστρέφει το αποτέλεσμα της συνάρτησης επαναλήπτη, την υπόσχεση που πρέπει να περιμένουμε. Επομένως, πρέπει να αντικαταστήσουμε το `forEach` με `map` που επιστρέφει αυτήν την υπόσχεση. Το `map` καθώς και όλες οι άλλες μέθοδοι επαναλήπτη των Arrays όπως `find`, `every`, `reduce` και άλλες, υλοποιούνται έτσι ώστε να σέβονται τις υποσχέσεις μέσα στις συναρτήσεις επαναλήπτη και είναι επομένως απλοποιημένες για τη χρήση τους σε ασύγχρονο περιβάλλον. Το παραπάνω παράδειγμα μοιάζει μετασχηματισμένο έτσι:

```js
const elems = await $$('div')
await elems.forEach((elem) => {
    return elem.click()
})
```

Για παράδειγμα, για να ανακτήσετε όλα τα στοιχεία `<h3 />` και να πάρετε το περιεχόμενο κειμένου τους, μπορείτε να εκτελέσετε:

```js
await browser.url('https://webdriver.io')

const h3Texts = await browser.$$('h3').map((img) => img.getText())
console.log(h3Texts);
/**
 * returns:
 * [
 *   'Extendable',
 *   'Compatible',
 *   'Feature Rich',
 *   'Who is using WebdriverIO?',
 *   'Support for Modern Web and Mobile Frameworks',
 *   'Google Lighthouse Integration',
 *   'Watch Talks about WebdriverIO',
 *   'Get Started With WebdriverIO within Minutes'
 * ]
 */
```

Εάν αυτό φαίνεται πολύ περίπλοκο, ίσως θέλετε να εξετάσετε τη χρήση απλών βρόχων for, π.χ.:

```js
const elems = await $$('div')
for (const elem of elems) {
    await elem.click()
}
```

### WebdriverIO Assertions

Εάν χρησιμοποιείτε τον βοηθό επιβεβαίωσης του WebdriverIO [`expect-webdriverio`](https://webdriver.io/docs/api/expect-webdriverio), βεβαιωθείτε ότι έχετε βάλει ένα `await` μπροστά από κάθε κλήση `expect`, π.χ.:

```ts
expect($('input')).toHaveAttributeContaining('class', 'form')
```

πρέπει να μετατραπεί σε:

```ts
await expect($('input')).toHaveAttributeContaining('class', 'form')
```

### Συγχρονισμένες Μέθοδοι PageObject και Ασύγχρονες Δοκιμές

Εάν έχετε γράψει PageObjects στη σουίτα δοκιμών σας με συγχρονισμένο τρόπο, δεν θα μπορείτε πλέον να τα χρησιμοποιήσετε σε ασύγχρονες δοκιμές. Εάν χρειάζεται να χρησιμοποιήσετε μια μέθοδο PageObject τόσο σε συγχρονισμένες όσο και σε ασύγχρονες δοκιμές, συνιστούμε να διπλασιάσετε τη μέθοδο και να την προσφέρετε και για τα δύο περιβάλλοντα, π.χ.:

```js
class MyPageObject extends Page {
    /**
     * define elements
     */
    get btnStart () { return $('button=Start') }
    get loadedPage () { return $('#finish') }

    someMethod () {
        // sync code
    }

    someMethodAsync () {
        // async version of MyPageObject.someMethod()
    }
}
```

Μόλις ολοκληρώσετε τη μετάβαση, μπορείτε να αφαιρέσετε τις συγχρονισμένες μεθόδους PageObject και να καθαρίσετε την ονομασία.

Εάν δεν θέλετε να διατηρήσετε δύο διαφορετικές εκδόσεις μιας μεθόδου PageObject, μπορείτε επίσης να μεταφέρετε ολόκληρο το PageObject σε async και να χρησιμοποιήσετε το [`browser.call`](https://webdriver.io/docs/api/browser/call) για να εκτελέσετε τη μέθοδο σε συγχρονισμένο περιβάλλον, π.χ.:

```js
// before:
// MyPageObject.someMethod()
// after:
browser.call(() => MyPageObject.someMethod())
```

Η εντολή `call` θα διασφαλίσει ότι η ασύγχρονη `someMethod` επιλύεται πριν προχωρήσει στην επόμενη εντολή.

## Συμπέρασμα

Όπως μπορείτε να δείτε στο [τελικό PR επανεγγραφής](https://github.com/webdriverio/cucumber-boilerplate/pull/481/files), η πολυπλοκότητα αυτής της επανεγγραφής είναι αρκετά εύκολη. Θυμηθείτε ότι μπορείτε να επανεγγράψετε έναν ορισμό βήματος κάθε φορά. Το WebdriverIO είναι απολύτως ικανό να χειριστεί συγχρονισμένη και ασύγχρονη εκτέλεση σε ένα ενιαίο πλαίσιο.